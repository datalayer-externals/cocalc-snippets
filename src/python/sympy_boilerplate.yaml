# CoCalc Examples Documentation File
# Copyright: CoCalc Authors, 2018
# This is derived content from the BSD licensed https://github.com/moble/jupyter_boilerplate/

# # # # # # # # # # # # # # # # # # # # # # # # # # #
# THIS FILE IS AUTOGENERATED -- DO NOT EDIT BY HAND #
# # # # # # # # # # # # # # # # # # # # # # # # # # #

---
language: python
---
category: ['Sympy', 'Constants']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  1
code: |
  S(1)
---
title: |
  1/2
code: |
  S(1)/2
---
title: |
  Rational numbers
code: |
  Rational(3, 7)
---
title: |
  Base of natural logarithm, \(e\)
code: |
  E
---
title: |
  Unit imaginary number, \(i\)
code: |
  I
---
title: |
  Geometric constant, \(\pi\)
code: |
  pi
---
title: |
  Golden ratio, \(\phi\)
code: |
  GoldenRatio
---
title: |
  Euler-Mascheroni constant, \(\gamma\)
code: |
  EulerGamma
---
title: |
  Catalan's constant, \(K\)
code: |
  Catalan
---
title: |
  Infinity, \(\infty\)
code: |
  oo
---
title: |
  Complex infinity, \(\tilde{\infty}\)
code: |
  zoo
---
title: |
  NaN
code: |
  nan
---
category: ['Sympy', 'Functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
category: ['Sympy', 'Functions / Elementary functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Abs
code: |
  Abs(-1)
---
title: |
  acos
code: |
  acos(S(1)/2)
---
title: |
  acosh
code: |
  acosh(S(1)/2)
---
title: |
  acot
code: |
  acot(1)
---
title: |
  acoth
code: |
  acoth(I)
---
title: |
  arg
code: |
  arg(exp(pi*I))
---
title: |
  asin
code: |
  asin(S(1)/2)
---
title: |
  asinh
code: |
  asinh(I)
---
title: |
  atan
code: |
  atan(1)
---
title: |
  atan2
code: |
  atan2(1,sqrt(3))
---
title: |
  atanh
code: |
  atanh(I)
---
title: |
  ceiling
code: |
  ceiling(S(3)/2)
---
title: |
  conjugate
code: |
  conjugate(1+I)
---
title: |
  cos
code: |
  cos(2*pi/3)
---
title: |
  cosh
code: |
  cosh(pi*I/3)
---
title: |
  cot
code: |
  cot(pi/4)
---
title: |
  coth
code: |
  coth(pi*I/4)
---
title: |
  exp
code: |
  exp(1+I)
---
title: |
  floor
code: |
  floor(S(3)/2)
---
title: |
  Identity function
code: |
  Id(x)
---
title: |
  im
code: |
  im(2+3*I)
---
title: |
  Lambert W (a.k.a. product logarithm)
code: |
  LambertW(x, n)
---
title: |
  log
code: |
  log(x)
---
title: |
  Min
code: |
  p = Symbol("p", negative=True)
  q = Symbol("q", positive=True)
  Min(p, q)
---
title: |
  Max
code: |
  p = Symbol("p", negative=True)
  q = Symbol("q", positive=True)
  Max(p, q)
---
title: |
  Piecewise
code: |
  Piecewise((0, x<1), (x**2, x>=5), (log(x), True))
---
title: |
  Product logarithm
code: |
  LambertW(x)
---
title: |
  re
code: |
  re(2+I)
---
title: |
  root
code: |
  root(-8, 3)
---
title: |
  sin
code: |
  sin(pi/4)
---
title: |
  sinh
code: |
  sinh(pi*I/2)
---
title: |
  sqrt
code: |
  sqrt(4)
---
title: |
  sign
code: |
  sign(-3)
---
title: |
  tan
code: |
  tan(pi/4)
---
title: |
  tanh
code: |
  tanh(pi*I/4)
---
category: ['Sympy', 'Functions / Combinatorial functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Bell number
code: |
  bell(n)
---
title: |
  Bell polynomial
code: |
  bell(n, k)
---
title: |
  Bell polynomial of the second kind
code: |
  n = 6
  k = 2
  x_j = symbols("x:{0}".format(n-k+1))
  bell(n, k, x_j)
---
title: |
  Bernoulli number
code: |
  bernoulli(n)
---
title: |
  Bernoulli polynomial
code: |
  bernoulli(n, x)
---
title: |
  Binomial coefficient (nCk)
code: |
  binomial(n, k)
---
title: |
  Catalan number
code: |
  catalan(n)
---
title: |
  Euler number
code: |
  euler(n)
---
title: |
  Factorial
code: |
  factorial(n)
---
title: |
  Double factorial
code: |
  factorial2(n)
---
title: |
  Falling factorial
code: |
  ff(x, k)
---
title: |
  Fibonacci number
code: |
  fibonacci(n)
---
title: |
  Fibonacci polynomial
code: |
  fibonacci(n, x)
---
title: |
  Harmonic number
code: |
  harmonic(n)
---
title: |
  Generalized harmonic number
code: |
  harmonic(n, m)
---
title: |
  Lucas number
code: |
  lucas(n)
---
title: |
  Rising factorial
code: |
  rf(x, k)
---
title: |
  Stirling number of the second kind
code: |
  from sympy.functions.combinatorial.numbers import stirling
  stirling(n, k)
---
title: |
  Stirling number of the first kind
code: |
  from sympy.functions.combinatorial.numbers import stirling
  stirling(n, k, kind=1, signed=False)
---
title: |
  Reduced Stirling number of the second kind
code: |
  from sympy.functions.combinatorial.numbers import stirling
  stirling(n, k, d)
---
title: |
  Number of combinations of length k among n items
code: |
  from sympy.functions.combinatorial.numbers import nC
  nC(n, k)
---
title: |
  Number of permutations of length k among n items
code: |
  from sympy.functions.combinatorial.numbers import nP
  nP(n, k)
---
title: |
  Number of partitions of length k among n items
code: |
  from sympy.functions.combinatorial.numbers import nT
  nT(n, k)
---
category: ['Sympy', 'Functions / Special functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Dirac delta function
code: |
  DiracDelta(x)
---
title: |
  Derivative of Dirac delta function
code: |
  DiracDelta(x, k)
---
title: |
  Heaviside function
code: |
  Heaviside(x)
---
category: ['Sympy', 'Special functions / Gamma, Beta and related Functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Gamma function
code: |
  gamma(x)
---
title: |
  Lower incomplete gamma function
code: |
  lowergamma(s, x)
---
title: |
  Upper incomplete gamma function
code: |
  uppergamma(s, x)
---
title: |
  Polygamma function
code: |
  polygamma(n, z)
---
title: |
  Log Gamma function
code: |
  loggamma(x)
---
title: |
  Digamma function
code: |
  digamma(x)
---
title: |
  Trigamma function
code: |
  trigamma(x)
---
title: |
  Euler Beta function
code: |
  beta(x, y)
---
category: ['Sympy', 'Special functions / Error Functions and Fresnel Integrals']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Gauss error function
code: |
  erf(x)
---
title: |
  Complementary error function
code: |
  erfc(x)
---
title: |
  Imaginary error function
code: |
  erfi(x)
---
title: |
  Two-argument error function
code: |
  erf2(x, y)
---
title: |
  Inverse error function
code: |
  erfinv(y)
---
title: |
  Inverse complementary error function
code: |
  erfcinv(y)
---
title: |
  Inverse two-argument error function
code: |
  erf2inv(x, y)
---
title: |
  Fresnel integral S
code: |
  fresnels(z)
---
title: |
  Fresnel integral C
code: |
  fresnelc(z)
---
category: ['Sympy', 'Special functions / Exponential, Logarithmic and Trigonometric Integrals']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Exponential integral
code: |
  Ei(x)
---
title: |
  Generalised exponential integral
code: |
  expint(x, z)
---
title: |
  Special case of the generalised exponential integral
code: |
  E1(z)
---
title: |
  Classical logarithmic integral
code: |
  li(x)
---
title: |
  Offset logarithmic integral
code: |
  Li(x)
---
title: |
  Sine integral
code: |
  Si(z)
---
title: |
  Cosine integral
code: |
  Ci(z)
---
title: |
  Hyperbolic sine integral
code: |
  Shi(z)
---
title: |
  Hyperbolic cosine integral
code: |
  Chi(z)
---
category: ['Sympy', 'Special functions / Bessel Type Functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Bessel function of the first kind
code: |
  besselj(n, z)
---
title: |
  Bessel function of the second kind
code: |
  bessely(n, z)
---
title: |
  Modified Bessel function of the first kind
code: |
  besseli(n, z)
---
title: |
  Modified Bessel function of the second kind
code: |
  besselk(n, z)
---
title: |
  Hankel function of the first kind
code: |
  hankel1(n, z)
---
title: |
  Hankel function of the second kind
code: |
  hankel2(n, z)
---
title: |
  Spherical Bessel function of the first kind
code: |
  jn(n, z)
---
title: |
  Spherical Bessel function of the second kind
code: |
  yn(n, z)
---
title: |
  Zeros of the spherical Bessel function of the first kind
code: |
  jn_zeros(n, k)
---
category: ['Sympy', 'Special functions / Airy Functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Airy function of the first kind
code: |
  airyai(z)
---
title: |
  Airy function of the second kind
code: |
  airybi(z)
---
title: |
  Derivative of the Airy function of the first kind
code: |
  airyaiprime(z)
---
title: |
  Derivative of the Airy function of the second kind
code: |
  airybiprime(z)
---
category: ['Sympy', 'Special functions / B-Splines']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  The n-th B-spline at x of degree d with given knots
code: |
  d = 3
  knots = range(5)
  n = 0
  bspline_basis(d, knots, n, x, close=True)
---
title: |
  The B-splines at x of degree d with given knots
code: |
  bspline_basis_set(d, knots, x)
---
category: ['Sympy', 'Special functions / Riemann Zeta and Related Functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Riemann zeta function
code: |
  zeta(s, 1)
---
title: |
  Hurwitz zeta function
code: |
  zeta(s, a)
---
title: |
  Dirichlet eta function
code: |
  dirichlet_eta(s)
---
title: |
  Polylogarithm function
code: |
  polylog(s, z)
---
title: |
  Lerch transcendent (Lerch phi function)
code: |
  lerchphi(z, s, a)
---
category: ['Sympy', 'Special functions / Hypergeometric Functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Generalized hypergeometric function
code: |
  p = 3
  q = 2
  a_j = symbols("a:{0}".format(p)) # numerator parameters
  b_k = symbols("b:{0}".format(q)) # denominator parameters
  hyper(a_j, b_k)
---
title: |
  Meijer G-function
code: |
  m,n = 1,2
  p,q = 4,1
  a_j = symbols("a:{0}".format(p)) # numerator parameters
  b_k = symbols("b:{0}".format(q)) # denominator parameters
  meijerg(a_j[:n], a_j[n:p], b_k[:m], b_k[m:q], x)
---
category: ['Sympy', 'Special functions / Elliptic integrals']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Complete elliptic integral of the first kind
code: |
  elliptic_k(z)
---
title: |
  Legendre incomplete elliptic integral of the first kind
code: |
  elliptic_f(z, m)
---
title: |
  Legendre incomplete elliptic integral of the second kind
code: |
  elliptic_e(z, m)
---
title: |
  Legendre incomplete elliptic integral of the third kind
code: |
  elliptic_pi(n, z, m)
---
category: ['Sympy', 'Special functions / Orthogonal Polynomials']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Jacobi polynomial
code: |
  jacobi(n, a, b, x)
---
title: |
  Normalized Jacobi polynomial
code: |
  jacobi_normalized(n, a, b, x)
---
title: |
  Gegenbauer polynomial
code: |
  gegenbauer(n, a, x)
---
title: |
  Chebyshev polynomial of the first kind
code: |
  chebyshevt(n, x)
---
title: |
  Chebyshev polynomial of the second kind
code: |
  chebyshevu(n, x)
---
title: |
  Root k of the nth Chebyshev polynomial of the first kind
code: |
  chebyshevt_root(n, k)
---
title: |
  Root k of the nth Chebyshev polynomial of the second kind
code: |
  chebyshevu_root(n, k)
---
title: |
  Legendre polynomial
code: |
  legendre(n, x)
---
title: |
  Associated Legendre polynomial
code: |
  assoc_legendre(n, m, x)
---
title: |
  Hermite polynomial
code: |
  hermite(n, x)
---
title: |
  Laguerre polynomial
code: |
  laguerre(n, x)
---
title: |
  Generalized (associated) Laguerre polynomial
code: |
  assoc_laguerre(n, a, x)
---
category: ['Sympy', 'Special functions / Spherical Harmonics']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Spherical harmonics
code: |
  vartheta, varphi = symbols("vartheta, varphi", real=True)
  Ynm(n, m, vartheta, varphi)
---
title: |
  Conjugate spherical harmonics
code: |
  vartheta, varphi = symbols("vartheta, varphi", real=True)
  Ynm_c(n, m, vartheta, varphi)
---
title: |
  Real spherical harmonics
code: |
  vartheta, varphi = symbols("vartheta, varphi", real=True)
  Znm(n, m, vartheta, varphi)
---
category: ['Sympy', 'Special functions / Tensor Functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Levi-Civita symbol
code: |
  LeviCivita(0,1,2,3)
---
title: |
  Kronecker delta
code: |
  KroneckerDelta(1,2)
---
category: ['Sympy', 'Calculus']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Differentiate once
code: |
  expr = exp(x**2)
  deriv = diff(expr, x)
---
title: |
  Differentiate multiple times
code: |
  expr = x**4
  deriv = diff(expr, x, 3)
---
title: |
  Mixed partial derivatives
code: |
  expr = exp(x*y*z)
  deriv = diff(expr, x, y, 2, z, 4)
---
title: |
  Finite differences
code: |
  dx0, dx1 = symbols("dx0, dx1")
  formula = as_finite_diff(f(x).diff(x), [x-dx0, x, x+dx1])
---
title: |
  Indefinite integral
code: |
  integral = integrate(cos(x), x)
---
title: |
  Definite integral
code: |
  integral = integrate(exp(-x), (x, 0, oo))
---
title: |
  Double integral
code: |
  integral = integrate(exp(-x**2-y**2), (x, -oo, oo), (y, -oo, oo))
---
title: |
  Limits
code: |
  lim = limit(sin(x)/x, x, 0, "+")
---
title: |
  Series expansion
code: |
  expr = exp(sin(x))
  ser = series(expr, x, 0, 6)
---
title: |
  Series expansion, removing order term
code: |
  expr = exp(sin(x))
  ser = series(expr, x, 0, 6).removeO()
---
title: |
  Summations
code: |
  ell_min,ell,ell_max = symbols("ell_min,ell,ell_max", integer=True)
  summ = summation((2*ell + 1), (ell, ell_min, ell_max))
---
category: ['Sympy', 'Solvers']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Solve for one variable
code: |
  expr = x**4 - 4*x**3 + 2*x**2 - x
  eqn = Eq(expr, 0)
  soln = solve(eqn, x)
---
title: |
  Solve for two variables
code: |
  eqns = Eq(x + y, 4), Eq(x*y, 3)
  soln = solve(eqns, [x,y])
---
title: |
  Solve differential equation
code: |
  expr = f(x).diff(x, x) + 9*f(x)
  eqn = Eq(expr, 1)  # f''(x) + 9f(x) = 1
  soln = dsolve(eqn, f(x))
---
category: ['Sympy', 'Manipulating expressions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Simplify
code: |
  expr = (x**3 + x**2 - x - 1)/(x**2 + 2*x + 1)
  expr = simplify(expr)
---
category: ['Sympy', 'Manipulating expressions / Refine, using assumptions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Refine
code: |
  expr = exp(pi*I*2*(x+y))
  assumption = Q.integer(x) & Q.integer(y)
  expr = refine(expr, assumption)
---
title: |
  Refine in context manager
code: |
  expr = exp(pi*I*2*(x+y))
  with assuming(Q.integer(x) & Q.integer(y)):
      expr = refine(expr)
---
category: ['Sympy', 'Refine, using assumptions / List of assumptions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Bounded
code: |
  Q.bounded(x)
---
title: |
  Commutative
code: |
  Q.commutative(x)
---
title: |
  Complex
code: |
  Q.complex(x)
---
title: |
  Imaginary
code: |
  Q.imaginary(x)
---
title: |
  Real
code: |
  Q.real(x)
---
title: |
  Extended real
code: |
  Q.extended_real(x)
---
title: |
  Integer
code: |
  Q.integer(x)
---
title: |
  Odd
code: |
  Q.odd(x)
---
title: |
  Even
code: |
  Q.even(x)
---
title: |
  Prime
code: |
  Q.prime(x)
---
title: |
  Composite
code: |
  Q.composite(x)
---
title: |
  Zero
code: |
  Q.zero(x)
---
title: |
  Nonzero
code: |
  Q.nonzero(x)
---
title: |
  Rational
code: |
  Q.rational(x)
---
title: |
  Algebraic
code: |
  Q.algebraic(x)
---
title: |
  Transcendental
code: |
  Q.transcendental(x)
---
title: |
  Irrational
code: |
  Q.irrational(x)
---
title: |
  Finite
code: |
  Q.finite(x)
---
title: |
  Infinite
code: |
  Q.infinite(x)
---
title: |
  Infinitesimal
code: |
  Q.infinitesimal(x)
---
title: |
  Negative
code: |
  Q.negative(x)
---
title: |
  Nonnegative
code: |
  Q.nonnegative(x)
---
title: |
  Positive
code: |
  Q.positive(x)
---
title: |
  Nonpositive
code: |
  Q.nonpositive(x)
---
title: |
  Hermitian
code: |
  Q.hermitian(x)
---
title: |
  Antihermitian
code: |
  Q.antihermitian(x)
---
category: ['Sympy', 'Manipulating expressions / Expansion']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Expand basic expressions
code: |
  expr = (x + 2)*(x - 3)
  expr = expand(expr)
---
title: |
  Expand, including complex parts
code: |
  expr = cos(x)
  expr = expand(expr, complex=True)
---
title: |
  Expand, including functions
code: |
  expr = gamma(x+3)
  expr = expand(expr, func=True)
---
title: |
  Expand, including trig
code: |
  expr = sin(x+y)*(x+y)
  expr = expand(expr, trig=True)
---
title: |
  Expand only real and imaginary parts
code: |
  expand_complex(x)
---
title: |
  Expand only functions
code: |
  expr = gamma(x + 2)
  expr = expand_func(expr)
---
title: |
  Expand only hypergeometric functions
code: |
  expr = hyper([1,1], [1,], z) + gamma(z)
  expr = hyperexpand(expr)
---
title: |
  Expand only logarithms
code: |
  a, b = symbols("a, b", positive=True)
  expr = log(a**2*b)
  expr = expand_log(expr)
---
title: |
  Expand only multiplication over addition
code: |
  expr = y*(x + z)
  expr = expand_mul(expr)
---
title: |
  Expand only multinomials
code: |
  expr = (x + y + z)**3
  expr = expand_multinomial(expr)
---
title: |
  Expand only powers of multiplied bases
code: |
  a, b = symbols("a, b", positive=True)
  expr = (a*b)**z
  expr = expand_power_base(expr)
---
title: |
  Expand only addition in exponents
code: |
  expr = x**(y + 2)
  expr = expand_power_exp(expr)
---
title: |
  Expand only trig
code: |
  expr = sin(x+y)*(x+y)
  expr = expand_trig(expr)
---
category: ['Sympy', 'Manipulating expressions / Collect terms']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Collect as coefficients of one factor
code: |
  expr = y*x**2 + z*x**2 + t*x - 2*x + 3
  expr = collect(expr, x)
---
title: |
  Collect as coefficients of multiple factors
code: |
  expr = x**2 + y*x**2 + x*y + y + z*y
  expr = collect(expr, [x, y])
---
title: |
  Collect with respect to wild card
code: |
  w = Wild("w")
  expr = z*x**y - t*z**y
  expr = collect(expr, w**y)
---
title: |
  Collect and apply function to each coefficient
code: |
  expr = expand((x + y + 1)**3)
  expr = collect(expr, x, factor)
---
title: |
  Recursively collect
code: |
  expr = (x**2*y + x*y + x + y)/(x*y + z*y)
  expr = rcollect(expr, y)
---
title: |
  Collect constants
code: |
  expr = sqrt(3)*x + sqrt(7)*x + sqrt(3) + sqrt(7)
  expr = collect_const(expr)
---
category: ['Sympy', 'Manipulating expressions / Substitutions and replacements']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Substitute one subexpression for another
code: |
  expr = 1 + x*y
  expr = expr.subs(x, pi)
---
title: |
  Substitute multiple subexpressions successively
code: |
  expr = (x+y)/y
  substitutions = [(x+y, y), (y, x+y)]
  expr = expr.subs(substitutions)
---
title: |
  Substitute multiple subexpressions simultaneously
code: |
  expr = (x+y)/y
  substitutions = [(x+y, y), (y, x+y)]
  expr = expr.subs(substitutions, simultaneous=True)
---
title: |
  Replace one object with another
code: |
  expr = 1 + x*y
  expr = expr.replace(x, pi)
---
title: |
  Replace one object with some function of its arguments
code: |
  expr = log(sin(x)) + tan(sin(x**2))
  expr = expr.replace(sin, lambda arg: sin(2*arg))
---
title: |
  Replace a pattern with an object
code: |
  # Note: `exclude=` specifies that the Wild cannot match any item in the list
  a, b = symbols("a, b", cls=Wild, exclude=[x,y])
  expr = 2*x + y + z
  wild = a*x + b
  replacement = b - a
  # Note: `exact=True` demands that all Wilds have nonzero matches
  expr = expr.replace(wild, replacement, exact=True)
---
title: |
  Replace a pattern with some function of that object
code: |
  a = symbols("a", cls=Wild, exclude=[])
  expr = log(sin(x)) + tan(sin(x**2))
  expr.replace(sin(a), lambda a: sin(2*a))
---
title: |
  Replace anything with some function of that thing
code: |
  g = 2*sin(x**3)
  g.replace(lambda expr: expr.is_Function, lambda expr: expr**2)
---
title: |
  Replace exact subexpressions
code: |
  expr = x**2 + x**4
  replacements = {x**2: y}
  expr = expr.xreplace(replacements)
---
category: ['Sympy', 'Manipulating expressions / Evaluation']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Evaluate numerically to arbitrary precision
code: |
  expr = x * sqrt(8)
  precision = 50
  val = N(expr, precision, subs={x:2.4})
---
title: |
  Evaluate numerically to python float
code: |
  expr = x * sqrt(8)
  val = float(expr.subs([(x, 2.4)]))
---
title: |
  Create numpy function for efficient evaluation
code: |
  import numpy
  a = numpy.arange(10)
  expr = sin(x)
  f = lambdify(x, expr, "numpy")
  vals = f(a)
---
category: ['Sympy', 'Manipulating expressions / Polynomials']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Factor polynomial over rationals
code: |
  expr = x**3 - x**2 + x - 1
  expr = factor(expr)
---
title: |
  Collect common powers of a term
code: |
  expr = x*y + x - 3 + 2*x**2 - z*x**2 + x**3
  expr = collect(expr, x)
---
title: |
  Extract coefficient of a term
code: |
  expr = 3+2*x+4*x**2
  expr = expr.coeff(x**2)
---
category: ['Sympy', 'Manipulating expressions / Rational functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Cancel
code: |
  expr = (x**2 + 2*x + 1)/(x**2 + x)
  expr = cancel(expr)
---
title: |
  Decompose into partial fractions
code: |
  expr = (4*x**3 + 21*x**2 + 10*x + 12)/(x**4 + 5*x**3 + 5*x**2 + 4*x)
  expr = apart(expr)
---
title: |
  Join over common denominator
code: |
  expr = 1/x + 1/y
  expr = ratsimp(expr)
---
title: |
  Remove square roots from denominator
code: |
  expr = 1/(1+I)
  expr = radsimp(expr)
---
category: ['Sympy', 'Manipulating expressions / Powers']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Simplify powers for general arguments
code: |
  powsimp(x**y * x**z)
---
title: |
  Simplify powers, forcing assumptions
code: |
  powsimp(x**y * x**z, force=True)
---
title: |
  Expand powers by exponent for general arguments
code: |
  expand_power_exp(x**(y + z))
---
title: |
  Expand powers of multiplied bases, forcing assumptions
code: |
  expand_power_base((x*y)**z, force=True)
---
title: |
  Collect exponents on powers for general arguments
code: |
  powdenest((x**y)**z)
---
title: |
  Collect exponents on powers, forcing assumptions
code: |
  powdenest((x**y)**z, force=True)
---
title: |
  Collect exponents on powers, forcing assumptions and polar simplifications
code: |
  powdenest((z**a)**b, force=True, polar=True)
---
title: |
  Denest square-roots
code: |
  sqrtdenest(sqrt(5 + 2*sqrt(6)))
---
category: ['Sympy', 'Manipulating expressions / Exponentials and Logarithms']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Combine exponentials
code: |
  powsimp(exp(y) * exp(z))
---
title: |
  Expand logarithms for general arguments
code: |
  expand_log(log(x*y))
---
title: |
  Expand logarithms, forcing assumptions
code: |
  expand_log(log(z**2), force=True)
---
title: |
  Combine logarithms for general arguments
code: |
  logcombine(log(x) + z*log(y))
---
title: |
  Combine logarithms, forcing assumptions
code: |
  logcombine(log(x) + z*log(y))
---
title: |
  Simplification, possibly to trig functions
code: |
  exptrigsimp(exp(z) + exp(-z))
---
category: ['Sympy', 'Manipulating expressions / Trigonometric functions']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Expansion
code: |
  expr = sin(x + y)
  expr = expand(expr, trig=True)
---
title: |
  Simplification
code: |
  expr = sin(x)**4 - 2*cos(x)**2*sin(x)**2 + cos(x)**4
  expr = trigsimp(expr)
---
title: |
  Simplification, possibly to exponentials
code: |
  expr = cosh(z) - sinh(z)
  expr = exptrigsimp(expr)
---
category: ['Sympy', 'Manipulating expressions / Miscellaneous']
setup: "from sympy import *\nfrom sympy.abc import a, b, s, t, u, v, w, x, y, z\nk, m, n = symbols(\"k, m, n\", integer=True)\nf, g, h = symbols(\"f, g, h\", cls=Function)"
variables: {"d":3}
---
title: |
  Simplify factorials
code: |
  expr = factorial(n)/factorial(n - 3)
  expr = combsimp(expr)
---
title: |
  Simplify binomials
code: |
  expr = binomial(n+1, k+1)/binomial(n, k)
  expr = combsimp(expr)
---
title: |
  Simplify numerical expressions to exact values
code: |
  nsimplify(4.0/(1+sqrt(5.0)), constants=[GoldenRatio,])
---
title: |
  Expand gamma functions
code: |
  expr = gamma(z+3)
  expr = expand_func(expr)
---
title: |
  Simplify Bessel functions
code: |
  expr = besselj(x, z*polar_lift(-1))
  expr = besselsimp(expr)