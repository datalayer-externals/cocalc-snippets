# CoCalc Examples Documentation File
# Copyright: CoCalc Authors, 2018
# This is derived content from the BSD licensed https://github.com/moble/jupyter_boilerplate/

---
language: python
---
category: ['Regular Expressions', 'Introduction']
setup: "import re"
sortweight: -1
---
title: "What's a regular expression?"
descr: |
  Defined in a simple way, a "regex" is a string of characters, which defines a set of strings.

  For example, `\w+` stands for all strings, which consist of a *w*ord character (letters and numbers),
  and appear one or more times. e.g. `"foo"`, `"abcdef"` but not `"foo bar"` or `""`.
  There is no limitation in lenght, and hence in that case, the set is infinite!
code:
  pattern = re.compile(r'\w+')
---
title: "Escaped special characters"
descr: |
  There are a couple of characters, which have a special meaning in regular expressions.
  If you want to refer to them as they are, they must be escaped with the `"\"` backslash character.

  This is the list: `.`, `^`, `$`, `*`, `+`, `?`, `{`, `}`, `[`, `]`, `\`, `|`, `(`, and `)`.

  Note, that the backslash itself needs to be escaped, too.
  This can be suppressed in Python strings by prepending the character `r`.

  The code of this example contains a substitution dictionary.
code: |
  special_chars = {
    '.' : r'\.',
    '^' : r'\^',
    '$' : r'\$',
    '*' : r'\*',
    '+' : r'\+',
    '?' : r'\?',
    '{' : r'\{',
    '}' : r'\}',
    '[' : r'\[',
    ']' : r'\]',
    '\' : r'\\',
    '|' : r'\|',
    '(' : r'\(',
    ')' : r'\)',
  }
---
title: Standard character-class abbreviations
code: ''
descr:
  ```
  Any decimal digit:              `\d`
  Any non-digit character:        `\D`
  Any whitespace character:       `\s`
  Any non-whitespace character:   `\S`
  Any alphanumeric character:     `\w`
  Any non-alphanumeric character: `\W`
  Inclusive character classes:    `[a-zA-Z0-9 \t\n\r\f\v]`
  Exclusive character classes:    `[^a-zA-Z0-9]`
  Alternatives:                   `(?:abc|def)`
---
title: Repetition
code: ''
descr: |
  List of modifyers for the number of repetitions of a character or class:
  * `*`: Match 0 or more repetitions of the preceding, greedily
  * `+`: Match 1 or more repetitions of the preceding, greedily
  * `?`: Match 0 or 1 repetitions of the preceding, greedily
  * `*?`: Match 0 or more repetitions of the preceding, non-greedily
  * `+?`: Match 1 or more repetitions of the preceding, non-greedily
  * `??`: Match 0 or 1 repetitions of the preceding, non-greedily
  * `{3}`: Match exactly n repeititions of the preceding
  * `{3,5}`: Match between m and n repetions of the preceding, greedily
  * `{3,5}?`: Match between m and n repetions of the preceding, non-greedily
---
category: ['Regular Expressions', 'Lookahead/behind']
setup: "import re"
---
title: |
  Positive lookahead
code: |
  string = "Isaac Asimov"
  pattern = re.compile(r"Isaac(?= Asimov)")  # Only match "Isaac Asimov", but drop the " Asimov"
  result = re.match(pattern, string)
  if result is not None:
      print("Substring '{0}' was found in the range {1}".format(result.group(), result.span()))
---
title: |
  Negative lookahead
code: |
  string = "Isaac Newton"
  pattern = re.compile(r"Isaac(?! Asimov)")  # Match any Isaac except Asimov, and only keep the "Isaac"
  result = re.match(pattern, string)
  if result is not None:
      print("Substring '{0}' was found in the range {1}".format(result.group(), result.span()))
---
title: |
  Positive lookbehind
code: |
  string = "Janet Asimov"
  pattern = re.compile(r"(?<=Janet )Asimov")  # Only match "Janet Asimov", but drop the "Janet "
  result = re.search(pattern, string)
  if result is not None:
      print("Substring '{0}' was found in the range {1}".format(result.group(), result.span()))
---
title: |
  Negative lookbehind
code: |
  string = "Janet Asimov"
  pattern = re.compile(r"(?<!Isaac )Asimov")  # Will match any Asimov except Isaac, and only keep "Asimov"
  result = re.search(pattern, string)
  if result is not None:
      print("Substring '{0}' was found in the range {1}".format(result.group(), result.span()))
---
category: ['Regular Expressions', 'Compilation flags']
setup: "import re"
---
title: |
  Enable verbose REs, for cleaner and more organized code
code: |
  pattern = re.compile(r"(?<!Isaac )Asimov", re.VERBOSE)
---
title: |
  Do case-insensitive matches
code: |
  pattern = re.compile(r"(?<!Isaac )Asimov", re.IGNORECASE)
---
title: |
  Make "." match any character, including newlines
code: |
  pattern = re.compile(r"(?<!Isaac )Asimov", re.DOTALL)
---
title: |
  Multi-line matching, affecting "^" and "$"
code: |
  pattern = re.compile(r"(?<!Isaac )Asimov", re.MULTILINE)
---
title: |
  Make \w, \W, \b, \B, \s, and \S Unicode aware
code: |
  pattern = re.compile(r"(?<!Isaac )Asimov", re.UNICODE)
---
title: |
  Make \w, \W, \b, \B, \s, and \S dependent on the current locale
code: |
  pattern = re.compile(r"(?<!Isaac )Asimov", re.LOCALE)
---
title: |
  Display debug info about compiled regex
code: |
  pattern = re.compile(r"(?<!Isaac )Asimov", re.DEBUG)