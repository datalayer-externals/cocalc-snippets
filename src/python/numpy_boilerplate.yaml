# CoCalc Examples Documentation File
# Copyright: CoCalc Authors, 2018
# This is derived content from the BSD licensed https://github.com/moble/jupyter_boilerplate/

# # # # # # # # # # # # # # # # # # # # # # # # # # #
# THIS FILE IS AUTOGENERATED -- DO NOT EDIT BY HAND #
# # # # # # # # # # # # # # # # # # # # # # # # # # #

---
language: python
---
category: ['NumPy', 'Creating arrays']
setup: "import numpy as np"
---
title: |
  New array of given shape
code: |
  new_array = np.zeros((4,3,), dtype=complex)
---
title: |
  New array shaped like another
code: |
  new_array = np.zeros_like(old_array, dtype=complex)
---
title: |
  Copy of existing data
code: |
  new_array = np.copy(old_array)
---
title: |
  Array from list of data
code: |
  new_array = np.array([1.2, 3.4, 5.6])
---
title: |
  Evenly spaced values within a given interval
code: |
  new_array = np.arange(1, 10, 2)
---
title: |
  Evenly spaced numbers over a specified interval
code: |
  new_array = np.linspace(1., 10., num=120, endpoint=True)
---
title: |
  Numbers spaced evenly on a log scale
code: |
  new_array = np.logspace(1., 10., num=120, endpoint=True, base=2)
---
title: |
  Coordinate matrices from coordinate vectors
code: |
  x = np.linspace(0, 1, 7)
  y = np.linspace(0, 1, 11)
  xx, yy = np.meshgrid(x, y)
---
title: |
  Return views of the data, split into $N$ groups
code: |
  x = np.arange(12)
  a,b,c = np.split(x, 3)
---
title: |
  Return views of the data, split at given indices along given axis
code: |
  x = np.arange(27).reshape((3,9))
  a,b,c = np.split(x, [2,6], axis=1)
---
title: |
  Return copy of arrays, combined into one
code: |
  a = np.arange(30).reshape((2,3,5))
  b = np.arange(42).reshape((2,3,7))
  c = np.concatenate((a, b), axis=1)
---
category: ['NumPy', 'Reshaping and viewing arrays']
setup: "import numpy as np"
---
title: |
  Return a view of the data, with a different shape
code: |
  np.arange(6).reshape((3, 2))
---
title: |
  Return a view of the data, with an extra axis
code: |
  a[:, np.newaxis]
---
title: |
  Return a view of the data, flattened to 1-D
code: |
  a.ravel()
---
title: |
  Return a copy of the data, flattened to 1-D
code: |
  a.flatten()
---
category: ['NumPy', 'Reshaping and viewing arrays / Return a view of the data, with a different dtype']
setup: "import numpy as np"
---
title: |
  View real array as complex
code: |
  r = np.linspace(0, 10, num=100).reshape((25,4))
  c = r.view(complex)
---
title: |
  View complex array as real with extra dimension
code: |
  c = (np.linspace(0, 10, num=50) + 1j*np.linspace(0, 10, num=50))
  cv = c.view(float)
  r = cv.reshape(c.shape + (2,))
---
title: |
  Return a copy of the data, cast to a different dtype
code: |
  np.linspace(0, 10, num=50).astype(complex)
---
title: |
  Return a view of the data with indices reversed (transposed)
code: |
  np.arange(210).reshape((2,3,5,7)).transpose()
---
title: |
  Return a view of the data with indices permuted
code: |
  np.arange(210).reshape((2,3,5,7)).transpose((2,1,0,3))
---
title: |
  Exchange two axes in an array
code: |
  np.arange(210).reshape((2,3,5,7)).swapaxes(1,3)
---
title: |
  Permute axes, bringing given axis into new position
code: |
  np.rollaxis(np.arange(210).reshape((2,3,5,7)), 2, 0)
---
title: |
  Permute indices by a given amount along the given axis
code: |
  np.roll(np.arange(10).reshape((2,5)), 2, axis=1)
---
title: |
  Return views of the data, split into $N$ groups
code: |
  x = np.arange(12)
  a,b,c = np.split(x, 3)
---
title: |
  Return views of the data, split at given indices along given axis
code: |
  x = np.arange(27).reshape((3,9))
  a,b,c = np.split(x, [2,6], axis=1)
---
title: |
  Return copy of arrays, combined into one
code: |
  a = np.arange(30).reshape((2,3,5))
  b = np.arange(42).reshape((2,3,7))
  c = np.concatenate((a, b), axis=1)
---
category: ['NumPy', 'Indexing']
setup: "import numpy as np"
---
title: |
  Test if array is empty
code: |
  if a.size > 0:  # Never use `if a` or `if len(a)` for numpy arrays
      print(a)
---
title: |
  Get number of dimensions of array
code: |
  a.ndim
---
title: |
  Get shape of array
code: |
  a.shape
---
category: ['NumPy', 'Indexing / Index a one-dimensional array']
setup: "import numpy as np"
---
title: |
  Get one element
code: |
  a = np.arange(10)
  a[3]
---
title: |
  Get first $N$ elements
code: |
  a = np.arange(10)
  a[:3]
---
title: |
  Get last $N$ elements
code: |
  a = np.arange(10)
  a[-3:]
---
title: |
  Get elements $N$ to $M$
code: |
  a = np.arange(10)
  a[3:6]
---
title: |
  Get elements satisfying a condition
code: |
  a = np.arange(10)
  a[a>5]
---
category: ['NumPy', 'Indexing / Index a multi-dimensional array']
setup: "import numpy as np"
---
title: |
  Get one element
code: |
  a = np.arange(30).reshape((2,3,5))
  a[1, 2, 4]
---
title: |
  Get first $N$ elements along each final axis
code: |
  a = np.arange(30).reshape((2,3,5))
  a[:, :, :4]
---
title: |
  Get last $N$ elements along each final axis
code: |
  a = np.arange(30).reshape((2,3,5))
  a[:, :, -3:]
---
title: |
  Get elements $N$ to $M$ along each final axis
code: |
  a = np.arange(30).reshape((2,3,5))
  a[:, :, 3:5]
---
title: |
  Get elements satisfying a condition (flattened result)
code: |
  a = np.arange(30).reshape((2,3,5))
  a[a>5]
---
category: ['NumPy', 'Indexing / Index an array of unknown dimension']
setup: "import numpy as np"
---
title: |
  Get first $N$ elements along each final axis
code: |
  a = np.arange(30).reshape((2,3,5))
  a[..., :4]
---
title: |
  Get last $N$ elements along each final axis
code: |
  a = np.arange(30).reshape((2,3,5))
  a[..., -3:]
---
title: |
  Get elements $N$ to $M$ along each final axis
code: |
  a = np.arange(30).reshape((2,3,5))
  a[..., 3:5]
---
title: |
  Get elements satisfying a condition (flattened result)
code: |
  a = np.arange(30).reshape((2,3,5))
  a[a>5]
---
category: ['NumPy', 'UFuncs']
setup: "import numpy as np"
---
category: ['NumPy', 'UFuncs / Characterizing arrays']
setup: "import numpy as np"
---
title: |
  max: Return the maximum along a given axis.
code: |
  np.max(a, axis=0)
---
title: |
  argmax: Return indices of the maximum values along the given axis.
code: |
  np.argmax(a, axis=0)
---
title: |
  min: Return the minimum along a given axis.
code: |
  np.min(a, axis=0)
---
title: |
  argmin: Return indices of the minimum values along the given axis of a.
code: |
  np.argmin(a, axis=0)
---
title: |
  ptp: Peak-to-peak (maximum - minimum) value along a given axis.
code: |
  np.ptp(a, axis=0)
---
title: |
  trace: Return the sum along diagonals of the array.
code: |
  np.trace(a, axis1, axis2)
---
title: |
  mean: Returns the average of the array elements along given axis.
code: |
  np.mean(a, axis=0)
---
title: |
  var: Returns the variance of the array elements, along given axis.
code: |
  np.var(a, axis=0)
---
title: |
  std: Returns the standard deviation of the array elements along given axis.
code: |
  np.std(a, axis=0)
---
title: |
  all: Returns True if all elements evaluate to True.
code: |
  np.all(a, axis=0)
---
title: |
  any: Returns True if any of the elements of a evaluate to True.
code: |
  np.any(a, axis=0)
---
category: ['NumPy', 'UFuncs / Sums, products, differences within array']
setup: "import numpy as np"
---
title: |
  prod: Product of array elements over a given axis
code: |
  np.prod(a, axis=0)
---
title: |
  sum: Sum of array elements over a given axis
code: |
  np.sum(a, axis=0)
---
title: |
  nansum: Sum of array elements over a given axis treating NaNs as zero
code: |
  np.nansum(a, axis=0)
---
title: |
  cumprod: Cumulative product of elements along a given axis
code: |
  np.cumprod(a, axis=0)
---
title: |
  cumsum: Cumulative sum of the elements along a given axis
code: |
  np.cumsum(a, axis=0)
---
title: |
  diff: Calculate the n-th order discrete difference along given axis
code: |
  np.diff(a, n, axis=0)
---
title: |
  ediff1d: Differences between consecutive elements of an array
code: |
  np.ediff1d(a)
---
title: |
  gradient: Gradient of an N-dimensional array
code: |
  np.gradient(f, *varargs, **kwargs)
---
title: |
  trapz: Integrate along the given axis using the composite trapezoidal rule
code: |
  np.trapz(y, x, dx, axis)
---
title: |
  convolve: Discrete, linear convolution of two one-dimensional sequences
code: |
  np.convolve(a, v)
---
title: |
  interp: One-dimensional linear interpolation
code: |
  np.interp(x, xp, fp)
---
category: ['NumPy', 'UFuncs / Logarithms and exponentials']
setup: "import numpy as np"
---
title: |
  logaddexp: Logarithm of the sum of exponentiations of the inputs
code: |
  np.logaddexp(x1, x2)
---
title: |
  logaddexp2: Logarithm of the sum of exponentiations of the inputs in base-2
code: |
  np.logaddexp2(x1, x2)
---
title: |
  power: First array elements raised to powers from second array, element-wise
code: |
  np.power(x1, x2)
---
title: |
  power: First array elements raised to powers from second array, element-wise with automatic domain
code: |
  # Use np.emath.power when input dtypes are float, but may contain negatives
  np.emath.power(x1, x2)
---
title: |
  exp: Calculate the exponential of all elements in the input array
code: |
  np.exp(x)
---
title: |
  exp2: Calculate $2^p$ for all $p$ in the input array
code: |
  np.exp2(x)
---
title: |
  log: Natural logarithm, element-wise
code: |
  np.log(x)
---
title: |
  log: Natural logarithm, element-wise with automatic domain
code: |
  # Use np.emath.log when input dtype is float, but may contain negatives
  np.emath.log(x)
---
title: |
  log2: Base-2 logarithm of $x$
code: |
  np.log2(x)
---
title: |
  log2: Base-2 logarithm of $x$ with automatic domain
code: |
  # Use np.emath.log2 when input dtype is float, but may contain negatives
  np.emath.log2(x)
---
title: |
  log10: Return the base 10 logarithm of the input array, element-wise
code: |
  np.log10(x)
---
title: |
  log10: Return the base 10 logarithm of the input array, element-wise with automatic domain
code: |
  # Use np.emath.log10 when input dtype is float, but may contain negatives
  np.emath.log10(x)
---
title: |
  logn: Return the base $n$ logarithm of the input array, element-wise with automatic domain
code: |
  # np.emath.logn allows for inputs with dtype float but possibly containing negatives
  np.emath.logn(n, x)
---
title: |
  expm1: Calculate $\exp(x) - 1$ for all elements in the array
code: |
  np.expm1(x)
---
title: |
  log1p: Calculate $\log(1+x)$ for all elements in the array
code: |
  np.log1p(x)
---
title: |
  sqrt: Return the positive square-root of an array, element-wise
code: |
  np.sqrt(x)
---
title: |
  sqrt: Return the positive square-root of an array, element-wise with automatic domain
code: |
  # Use np.emath.sqrt when argument may contain negative real numbers
  np.emath.sqrt(x)
---
title: |
  square: Return the element-wise square of the input
code: |
  np.square(x)
---
title: |
  reciprocal: Return the reciprocal of the argument, element-wise
code: |
  np.reciprocal(x)
---
category: ['NumPy', 'UFuncs / Trigonometric and hyperbolic functions']
setup: "import numpy as np"
---
title: |
  sin: Trigonometric sine, element-wise
code: |
  np.sin(x)
---
title: |
  cos: Cosine element-wise
code: |
  np.cos(x)
---
title: |
  tan: Compute tangent element-wise
code: |
  np.tan(x)
---
title: |
  arcsin: Trigonometric inverse sine, element-wise
code: |
  np.arcsin(x)
---
title: |
  arcsin: Trigonometric inverse sine, element-wise with automatic domain
code: |
  # Use np.emath.arcsin when input dtype is float, but may contain values outside of [-1,1]
  np.emath.arcsin(x)
---
title: |
  arccos: Trigonometric inverse cosine, element-wise
code: |
  np.arccos(x)
---
title: |
  arccos: Trigonometric inverse cosine, element-wise with automatic domain
code: |
  # Use np.emath.arccos when input dtype is float, but may contain values outside of [-1,1]
  np.emath.arccos(x)
---
title: |
  arctan: Trigonometric inverse tangent, element-wise
code: |
  np.arctan(x)
---
title: |
  arctan2: Element-wise arc tangent of $x_1/x_2$ choosing the quadrant correctly
code: |
  np.arctan2(x1, x2)
---
title: |
  hypot: Given the “legs” of a right triangle, return its hypotenuse
code: |
  np.hypot(x1, x2)
---
title: |
  sinh: Hyperbolic sine, element-wise
code: |
  np.sinh(x)
---
title: |
  cosh: Hyperbolic cosine, element-wise
code: |
  np.cosh(x)
---
title: |
  tanh: Compute hyperbolic tangent element-wise
code: |
  np.tanh(x)
---
title: |
  arcsinh: Inverse hyperbolic sine element-wise
code: |
  np.arcsinh(x)
---
title: |
  arccosh: Inverse hyperbolic cosine, element-wise
code: |
  np.arccosh(x)
---
title: |
  arctanh: Inverse hyperbolic tangent, element-wise
code: |
  np.arctanh(x)
---
title: |
  arctanh: Inverse hyperbolic tangent, element-wise with automatic domain
code: |
  # Use np.emath.arctanh when input dtype is float, but may contain values outside of (-1,1)
  np.emath.arctanh(x)
---
title: |
  deg2rad: Convert angles from degrees to radians
code: |
  np.deg2rad(x)
---
title: |
  rad2deg: Convert angles from radians to degrees
code: |
  np.rad2deg(x)
---
title: |
  unwrap: Unwrap radian phase by changing jumps greater than $\pi$ to their $2\pi$ complement
code: |
  np.unwrap(x)
---
category: ['NumPy', 'UFuncs / Complex numbers']
setup: "import numpy as np"
---
title: |
  real: Real part of the elements of the array
code: |
  np.real(a)
---
title: |
  imag: Imaginary part of the elements of the array
code: |
  np.imag(a)
---
title: |
  conj: Complex conjugate, element-wise
code: |
  np.conj(a)
---
title: |
  angle: Angle of the complex argument
code: |
  np.angle(a)
---
title: |
  unwrap: Unwrap radian phase by changing jumps greater than $\pi$ to their $2\pi$ complement
code: |
  np.unwrap(x)
---
category: ['NumPy', 'UFuncs / Rounding and clipping']
setup: "import numpy as np"
---
title: |
  around: Evenly round to the given number of decimals
code: |
  np.around(a, decimals=2)
---
title: |
  rint: Round elements of the array to the nearest integer
code: |
  np.rint(a)
---
title: |
  fix: Round to nearest integer towards zero
code: |
  np.fix(a)
---
title: |
  floor: Floor of the input, element-wise
code: |
  np.floor(a)
---
title: |
  ceil: Ceiling of the input, element-wise
code: |
  np.ceil(a)
---
title: |
  trunc: Truncated value of the input, element-wise
code: |
  np.trunc(a)
---
title: |
  clip: Clip (limit) the values in an array
code: |
  np.clip(a, a_min, a_max)
---
title: |
  nan_to_num: Replace NaNs with zero and inf with finite numbers
code: |
  np.nan_to_num(a)
---
title: |
  real_if_close: Truncate complex parts if within `tol` times machine epsilon of zero
code: |
  np.real_if_close(a, tol=100)
---
category: ['NumPy', 'UFuncs / Float functions']
setup: "import numpy as np"
---
title: |
  isreal: Returns a bool array, where True if input element is real
code: |
  np.isreal(x)
---
title: |
  iscomplex: Returns a bool array, where True if input element is complex
code: |
  np.iscomplex(x)
---
title: |
  isfinite: Test element-wise for finiteness (not infinity and not NaN)
code: |
  np.isfinite(x)
---
title: |
  isinf: Test element-wise for positive or negative infinity
code: |
  np.isinf(x)
---
title: |
  isnan: Test element-wise for NaN and return result as a boolean array
code: |
  np.isnan(x)
---
title: |
  signbit: Returns element-wise True where signbit is set (less than zero)
code: |
  np.signbit(x)
---
title: |
  copysign: Change the sign of $x_1$ to that of $x_2$, element-wise
code: |
  np.copysign(x1, x2)
---
title: |
  nextafter: Return the next floating-point value after $x_1$ towards $x_2$, element-wise
code: |
  np.nextafter(x1, x2)
---
title: |
  modf: Return the fractional and integral parts of an array, element-wise
code: |
  np.modf(x)
---
title: |
  ldexp: Returns $x_1\, 2^{x_2}$, element-wise
code: |
  np.ldexp(x1, x2)
---
title: |
  frexp: Decompose the elements of $x$ into mantissa and twos exponent
code: |
  np.frexp(x)
---
title: |
  fmod: Return the element-wise remainder of division
code: |
  np.fmod(x1, x2)
---
title: |
  floor: Return the floor of the input, element-wise
code: |
  np.floor(x)
---
title: |
  ceil: Return the ceiling of the input, element-wise
code: |
  np.ceil(x)
---
title: |
  trunc: Return the truncated value of the input, element-wise
code: |
  np.trunc(x)
---
category: ['NumPy', 'UFuncs / Bit-twiddling functions']
setup: "import numpy as np"
---
title: |
  bitwise_and: Compute the bit-wise AND of two arrays element-wise
code: |
  np.bitwise_and(x1, x2)
---
title: |
  bitwise_or: Compute the bit-wise OR of two arrays element-wise
code: |
  np.bitwise_or(x1, x2)
---
title: |
  bitwise_xor: Compute the bit-wise XOR of two arrays element-wise
code: |
  np.bitwise_xor(x1, x2)
---
title: |
  invert: Compute bit-wise inversion, or bit-wise NOT, element-wise
code: |
  np.invert(x)
---
title: |
  left_shift: Shift the bits of an integer to the left
code: |
  np.left_shift(x1, x2)
---
title: |
  right_shift: Shift the bits of an integer to the right
code: |
  np.right_shift(x1, x2)
---
category: ['NumPy', 'UFuncs / Special functions (see scipy.special)']
setup: "import numpy as np"
---
title: |
  i0: Modified Bessel function of the first kind, order 0
code: |
  np.i0(x)
---
title: |
  sinc: Return the sinc function
code: |
  np.sinc(x)
---
category: ['NumPy', 'UFuncs / Arithmetic']
setup: "import numpy as np"
---
title: |
  add: Add arguments element-wise
code: |
  np.add(x1, x2)
---
title: |
  subtract: Subtract arguments, element-wise
code: |
  np.subtract(x1, x2)
---
title: |
  multiply: Multiply arguments element-wise
code: |
  np.multiply(x1, x2)
---
title: |
  divide: Divide arguments element-wise
code: |
  np.divide(x1, x2)
---
title: |
  true_divide: Returns a true division of the inputs, element-wise
code: |
  np.true_divide(x1, x2)
---
title: |
  floor_divide: Return the largest integer smaller or equal to the division of the inputs
code: |
  np.floor_divide(x1, x2)
---
title: |
  negative: Numerical negative, element-wise
code: |
  np.negative(x)
---
title: |
  remainder: Return element-wise remainder of integer division
code: |
  np.remainder(x1, x2)
---
title: |
  mod: Return element-wise remainder of integer division
code: |
  np.mod(x1, x2) # identical to np.remainder
---
title: |
  fmod: Return element-wise remainder of float division
code: |
  np.fmod(x1, x2)
---
title: |
  modf: Return the fractional and integral parts of an array, element-wise
code: |
  np.modf(x)
---
title: |
  absolute: Calculate the absolute value element-wise
code: |
  np.absolute(x)
---
title: |
  rint: Round elements of the array to the nearest integer
code: |
  np.rint(x)
---
title: |
  sign: Returns an element-wise indication of the sign of a number
code: |
  np.sign(x)
---
title: |
  conj: Return the complex conjugate, element-wise
code: |
  np.conj(x)
---
title: |
  sqrt: Return the positive square-root of an array, element-wise
code: |
  np.sqrt(x)
---
title: |
  sqrt: Return the positive square-root of an array, element-wise with automatic domain
code: |
  # Use np.emath.sqrt when argument may contain negative real numbers
  np.emath.sqrt(x)
---
title: |
  square: Return the element-wise square of the input
code: |
  np.square(x)
---
title: |
  reciprocal: Return the reciprocal of the argument, element-wise
code: |
  np.reciprocal(x)
---
category: ['NumPy', 'UFuncs / Matrix and vector products']
setup: "import numpy as np"
---
title: |
  tensordot: Tensor dot product over last $n$ axes of a and first $n$ of b
code: |
  a = np.arange(60).reshape((5,3,4))
  b = np.arange(84).reshape((3,4,7))
  n = 2
  np.tensordot(a, b, n)
---
title: |
  tensordot: Tensor dot product over given pairs of axes
code: |
  a = np.arange(24).reshape((3,4,2))
  axes_a = (2, 0)
  b = np.arange(30).reshape((2,3,5))
  axes_b = (0, 1)
  np.tensordot(a, b, (axes_a, axes_b))
---
title: |
  einsum: Evaluate Einstein summation convention on operands
code: |
  a = np.arange(6).reshape((3,2))
  b = np.arange(12).reshape((4,3))
  np.einsum('ki,jk->ij', a, b)
---
title: |
  inner: Inner product, summing over last two axes
code: |
  a = np.arange(24).reshape((2,3,4))
  b = np.arange(4)
  np.inner(a, b)
---
title: |
  outer: Compute outer product of two vectors (automatically flattened)
code: |
  a = np.ones((5,))
  b = np.linspace(-2, 2, 5)
  np.outer(a, b)
---
title: |
  kron: Kronecker product of arrays
code: |
  np.kron(np.eye(2), np.ones((2,2)))
---
title: |
  cross: Cross product of two (arrays of) vectors
code: |
  np.cross(a, b)
---
category: ['NumPy', 'UFuncs / Comparisons between two arrays']
setup: "import numpy as np"
---
title: |
  greater: Return the truth value of $(x_1 > x_2)$ element-wise
code: |
  np.greater(x1, x2)
---
title: |
  greater_equal: Return the truth value of $(x_1 \geq x_2)$ element-wise
code: |
  np.greater_equal(x1, x2)
---
title: |
  less: Return the truth value of $(x_1 < x_2)$ element-wise
code: |
  np.less(x1, x2)
---
title: |
  less_equal: Return the truth value of $(x_1 \leq x_2)$ element-wise
code: |
  np.less_equal(x1, x2)
---
title: |
  not_equal: Return $(x_1 != x_2)$ element-wise
code: |
  np.not_equal(x1, x2)
---
title: |
  equal: Return $(x_1 == x_2)$ element-wise
code: |
  np.equal(x1, x2)
---
title: |
  logical_and: Compute the truth value of $x_1$ AND $x_2$ element-wise
code: |
  np.logical_and(x1, x2)
---
title: |
  logical_or: Compute the truth value of $x_1$ OR $x_2$ element-wise
code: |
  np.logical_or(x1, x2)
---
title: |
  logical_xor: Compute the truth value of $x_1$ XOR $x_2$, element-wise
code: |
  np.logical_xor(x1, x2)
---
title: |
  logical_not: Compute the truth value of NOT $x$ element-wise
code: |
  np.logical_not(x)
---
title: |
  maximum: Element-wise maximum of array elements
code: |
  np.maximum(x1, x2)
---
title: |
  minimum: Element-wise minimum of array elements
code: |
  np.minimum(x1, x2)
---
title: |
  fmax: Element-wise maximum of array elements
code: |
  np.fmax(x1, x2)
---
title: |
  fmin: Element-wise minimum of array elements
code: |
  np.fmin(x1, x2)
---
category: ['NumPy', 'Polynomials']
setup: "import numpy as np\nfrom numpy.polynomial import Polynomial as P\npoly = P([1, 2, 3])"
---
title: |
  Setup
code: |
  import numpy as np
  from numpy.polynomial import Polynomial as P
  from numpy.polynomial import Chebyshev as T
  from numpy.polynomial import Legendre as Le
  from numpy.polynomial import Laguerre as La
  from numpy.polynomial import Hermite as H
  from numpy.polynomial import HermiteE as HE
---
title: |
  Instantiate from coefficients
code: |
  poly = P([1, 2, 3])
---
title: |
  Instantiate from roots
code: |
  poly = P.fromroots([1, 2, 3])
---
title: |
  Instantiate from basis element $n$
code: |
  poly = P.basis(n)
---
title: |
  Convert between types
code: |
  from numpy.polynomial import Chebyshev
  polyT = poly.convert(kind=Chebyshev)
---
title: |
  Get coefficients (constant at index 0, higher indices for higher orders)
code: |
  poly.coeff
---
title: |
  Get domain (scaled and offset domain of function for fitting)
code: |
  poly.domain
---
title: |
  Get window (natural domain of basis functions)
code: |
  poly.window
---
title: |
  Get degree of polynomial (one less than number of coefficients)
code: |
  poly.degree()
---
title: |
  Evaluate polynomial at given points
code: |
  x = np.linspace(0, 3.14)
  poly(x)
---
title: |
  Return $n$ equally spaced $(x,y)$ values
code: |
  x, y = poly.linspace(n=100)
---
title: |
  Find roots
code: |
  poly.roots()
---
title: |
  Differentiate once
code: |
  poly.deriv()
---
title: |
  Differentiate $n$ times
code: |
  poly.deriv(n)
---
title: |
  Integrate once
code: |
  poly.integ()
---
title: |
  Integrate $n$ times
code: |
  poly.integ(n)
---
title: |
  Integrate with given lower bound and integration constant $k$
code: |
  poly.integ(lbnd=0.1, k=-2.34)
---
title: |
  Fit to data with series of degree $n$
code: |
  np.random.seed(11)
  x = np.linspace(0, 2*np.pi, 20)
  y = np.sin(x) + np.random.normal(scale=.1, size=x.shape)
  n = 5
  p = T.fit(x, y, n)
---
category: ['NumPy', 'Pretty printing']
setup: "import numpy as np"
---
title: |
  Context manager
code: |
  import contextlib
  @contextlib.contextmanager
  def printoptions(*args, **kwargs):
      original = np.get_printoptions()
      np.set_printoptions(*args, **kwargs)
      yield
      np.set_printoptions(**original)
---
title: |
  Print to given precision
code: |
  with printoptions(precision=5):
      print(np.random.random(10))
---
title: |
  Summarize arrays with more than $N+1$ elements
code: |
  with printoptions(threshold=5):
      print(np.random.random(10))
---
title: |
  Print $N$ elements at each end of a summary
code: |
  with printoptions(threshold=5, edgeitems=4):
      print(np.random.random(10))
---
title: |
  Set number of characters per line
code: |
  with printoptions(linewidth=100):
      print(np.random.random(10))
---
title: |
  Suppress printing of small values
code: |
  with printoptions(suppress=True):
      print(1e-8*np.random.random(10))
---
title: |
  Set string with which to represent nan
code: |
  with printoptions(nanstr='NaN!'):
      print(np.array([1, np.nan, 3]))
---
title: |
  Set string with which to represent infinity
code: |
  with printoptions(infstr='oo'):
      print(np.array([1, np.inf, 3]))
---
category: ['NumPy', 'Pretty printing / Formatting functions for specific dtypes']
setup: "import numpy as np"
---
title: |
  Set formatter for `bool` type
code: |
  def format_bool(x):
      if x:
          return 'TRUE'
      else:
          return 'FALSE'
  with printoptions(formatter={'bool': format_bool}):
      print(np.random.randint(0,2,10).astype(bool))
---
title: |
  Set formatter for `int` type
code: |
  def format_int(x):
      return 'int({0})'.format(x)
  with printoptions(formatter={'int': format_int}):
      print(np.random.randint(-3, 4, 10))
---
title: |
  Set formatter for `timedelta` type
code: |
  def format_timedelta(delta):
      days = delta.astype('timedelta64[D]').astype(int)
      hours = delta.astype('timedelta64[h]').astype(int) - 24*days
      minutes = delta.astype('timedelta64[m]').astype(int) - 60*(24*days+hours)
      seconds = delta.astype('timedelta64[s]').astype(int) - 60*(60*(24*days+hours)+minutes)
      return '{0}days,{1}hours,{2}minutes,{3}seconds'.format(days, hours, minutes, seconds)
  with printoptions(formatter={'timedelta': format_timedelta}):
      print(np.array([np.timedelta64(int(sec), 's') for sec in np.random.randint(0, 1000000, 10)]))
---
title: |
  Set formatter for `datetime` type
code: |
  def format_datetime(date):
      year = date.astype('datetime64[Y]').astype(int) + 1970
      month = date.astype('datetime64[M]').astype(int) % 12 + 1
      day = (date - date.astype('datetime64[M]')).astype(int) + 1
      return 'Y{0}:M{1}:D{2}'.format(year, month, day)
  with printoptions(formatter={'datetime': format_datetime}):
      days = np.random.randint(0, 20000, 10)
      dates = np.array([np.datetime64(int(d), 'D') for d in days])
      print(dates)
---
title: |
  Set formatter for `float` type
code: |
  def format_float(x):
      return '{0:+0.2f}'.format(x)
  with printoptions(formatter={'float': format_float}):
      print(np.random.random(10)-0.5)
---
title: |
  Set formatter for `longfloat` type
code: |
  def format_longfloat(x):
      return 'long{0}'.format(x)
  with printoptions(formatter={'longfloat': format_longfloat}):
      print(np.random.random(10).astype(np.longfloat))
---
title: |
  Set formatter for `complexfloat` type
code: |
  def format_complexfloat(x):
      return '{0.real}+1j*{0.imag}'.format(x)
  with printoptions(formatter={'complexfloat': format_complexfloat}):
      print(np.random.random(5)+1j*np.random.random(5))
---
title: |
  Set formatter for `longcomplexfloat` type
code: |
  def format_longcomplexfloat(x):
      return '{0.real}+1j*{0.imag}'.format(x)
  with printoptions(formatter={'longcomplexfloat': format_longcomplexfloat}):
      print(np.random.random(5).astype(np.longfloat)+1j*np.random.random(5).astype(np.longfloat))
---
title: |
  Set formatter for all types
code: |
  def format_all(x):
      return 'repr({0})'.format(repr(x))
  with printoptions(formatter={'all': format_all}):
      print(np.array([3, 8]))
      print(np.array([0.1, 0.5]))
      print(np.array([1.4+2.3j, 2.8+4.6j]))
      print(np.array(['abc', 'xyz']))
---
title: |
  Set formatter for all `int` types
code: |
  def format_int_kind(x):
      return 'int({0})'.format(x)
  with printoptions(formatter={'int_kind': format_int_kind}):
      print(np.random.randint(-100, 100, 10))
---
title: |
  Set formatter for all `float` types
code: |
  def format_float_kind(x):
      return '{0:.2%}'.format(x)
  with printoptions(formatter={'float_kind': format_float_kind}):
      print(np.random.random(10))
---
title: |
  Set formatter for all `complex` types
code: |
  def format_complex_kind(x):
      return '{0.real}+1j*{0.imag}'.format(x)
  with printoptions(formatter={'complex_kind': format_complex_kind}):
      print(np.random.random(5)+1j*np.random.random(5))
---
title: |
  Set formatter for all `str` types
code: |
  def format_str_kind(x):
      return 'str({0})'.format(x)
  with printoptions(formatter={'str_kind': format_str_kind}):
      print(np.array(['abc', 'xyz']))
---
category: ['NumPy', 'File I/O']
setup: "import numpy as np"
---
title: |
  Read data from simple text file
code: |
  data = np.loadtxt(filename)
---
title: |
  Read data from text file with missing values
code: |
  data = np.genfromtxt(filename)
---
title: |
  Read data from .npy or .npz file
code: |
  data = np.load(filename)
---
title: |
  Write single array to text file
code: |
  np.savetxt(filename, x)
---
title: |
  Write multiple arrays to text file
code: |
  np.savetxt(filename, np.transpose((x, y, z)))
---
title: |
  Write single array to single .npy file
code: |
  np.save(filename, x)
---
title: |
  Write multiple arrays to single .npy file
code: |
  np.save(filename, np.transpose((x, y, z)))
---
title: |
  Write multiple arrays to single .npz file
code: |
  np.savez(filename, x, y, z)
---
title: |
  Write multiple arrays to single compressed .npz file
code: |
  np.savez_compressed(filename, x, y, z)